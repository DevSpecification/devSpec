<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>开发规范 – 编码协作规范</title><link>/docs/codestandards/</link><description>Recent content in 编码协作规范 on 开发规范</description><generator>Hugo -- gohugo.io</generator><atom:link href="/docs/codestandards/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Git工作流</title><link>/docs/codestandards/gitflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/codestandards/gitflow/</guid><description>
&lt;p>目前基于 &lt;code>git&lt;/code> 协作工作流的模式非常多，对于初创团队可以借鉴 &lt;code>gitflow&lt;/code> 构建协作方式。此外，通过统一的协作工作流程和开发工作流，
保证团队高效地协作开发，保持项目开发迭代周期井井有序。&lt;/p>
&lt;p>团队开发与维护主要是针对项目去开发、迭代甚至是维护，使用分支能够有效地避免不同开发工作之间的相关干扰。&lt;/p>
&lt;p>&lt;img src="/images/gitflow.png" alt="gitflow">&lt;/p>
&lt;h2 id="git提交规范">Git提交规范&lt;/h2>
&lt;p>当一个团队在协作开发时，针对 &lt;strong>git commit&lt;/strong> 规范是十分必须的，每一次提交都务必带上说明信息，同时说明信息亦要有格式规范，
即团队要有良好的约定。目的是制定统一的标准，使得提交历史信息条理清晰，更是为了项目有条不絮地迭代以及提高开发者的效率。&lt;/p>
&lt;blockquote>
&lt;p>统一团队 git commit 日志标准，便于后续代码 review ，版本发布以及日志自动化生成等等。&lt;/p>
&lt;/blockquote>
&lt;p>提交格式包含提交类别、范围模块、描述说明三部分：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git commit -m &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>type&lt;span style="color:#ce5c00;font-weight:bold">](&lt;/span>:scope&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>subject&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>例子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git commit -m &lt;span style="color:#4e9a06">&amp;#34;feature:log:algo log by using websocket&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;p>&lt;strong>提交类别&lt;/strong>包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>feature&lt;/code>: 新功能&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>fixed&lt;/code> : 修复bug&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>update&lt;/code> : 更新&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>docs&lt;/code> : 文档改变&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>style&lt;/code> : 代码格式改变&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>refactor&lt;/code> : 某个已有功能重构&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>perf&lt;/code> : 性能优化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>test&lt;/code> : 增加测试&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>build&lt;/code> : 改变了build工具 如 grunt换成了 npm&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>revert&lt;/code> : 撤销上一次的 commit&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>chore&lt;/code> : 构建过程或辅助工具的变动&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>范围模块&lt;/strong>，应该使用一个词语涵盖此次提交的改动。&lt;/p>
&lt;p>&lt;strong>描述说明&lt;/strong>，应该简洁明了，同时更加能突出此次改动的内容即可。&lt;/p>
&lt;h2 id="git分支规范">Git分支规范&lt;/h2>
&lt;ul>
&lt;li>长期存在分支或标签&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>&lt;code>master&lt;/code> | 主分支&lt;/p>
&lt;p>主分支属于线上部署的分支，是项目生产稳定运行的项目分支，该分支自能合并开发分支或热修复分支。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>develop&lt;/code> | 开发分支&lt;/p>
&lt;p>开发分支与主分支必须是并行的，此分支基于运行于开发环境与测试环境。同时，从规范上面来说，尽量不要在开发分支上直接做开发，
开发分支是由功能分支或修复分支合并叠成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>release&lt;/code>| 发行标签&lt;/p>
&lt;p>发行分支即是项目版本可以稳定发行的版本，可看作为一个版本迭代的分水岭，譬如&lt;code>1.0.0&lt;/code>、&lt;code>2.0.0&lt;/code>等。注意、此发行分支是基于主分支构建而来，
主要用于记录版本的节点，必须基于 &lt;code>master&lt;/code> 分支构建。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>短期存在分支&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>&lt;code>feature&lt;/code> | 功能分支&lt;/p>
&lt;p>功能分支由需求确立而成，每新增一个需求或功能就必须建立一个功能分支，好处是各个功能独立开发不受影响，同时团队成员之间的实现协作隔离不容易产生冲突。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>hotfix&lt;/code> | 热修复分支&lt;/p>
&lt;p>热修复分支（补丁分支）假设生产分支出现异常等 &lt;code>bug&lt;/code> 危急的情况，需要建议一个修复分支，使得主分支合并进而解决 &lt;code>bug&lt;/code>则需要创建热修复分支。&lt;/p>
&lt;blockquote>
&lt;p>注意:修复分支在主分支合并的同时必须同时与开发分支合并，发行版也要合并构建成小版本的发行版，测试通过后需要基于热修复分支打标签。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>分支名&lt;/th>
&lt;th>分支定位&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>权限控制&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>master&lt;/td>
&lt;td>发布分支&lt;/td>
&lt;td>master应处于随时可发布的状态，用于对外发布正式版本。ps: 应配置此分支触发CI/CD，部署至生产环境。&lt;/td>
&lt;td>Maintainer可发起merge request&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>develop&lt;/td>
&lt;td>开发分支&lt;/td>
&lt;td>不可以在develop分支push代码，应新建feature/xxx进行需求开发。迭代功能开发完成后的代码都会merge到develop分支。&lt;/td>
&lt;td>Develper不可直接push，可发起merge request&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>feature/xxx&lt;/td>
&lt;td>特性分支&lt;/td>
&lt;td>针对每一项需求，新建feature分支，如feature/user_login，用于开发用户登录功能。&lt;/td>
&lt;td>Develper可直接push&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>release&lt;/td>
&lt;td>提测分支&lt;/td>
&lt;td>由develop分支合入release分支。ps: 应配置此分支触发CI/CD，部署至测试环境。&lt;/td>
&lt;td>Maintainer可发起merge request&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>bug/xxx&lt;/td>
&lt;td>缺陷分支&lt;/td>
&lt;td>提测后发现的bug，应基于develop分支创建bug/xxx分支修复缺陷，修改完毕后应合入develop分支等待回归测试。&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>hotfix/xxx&lt;/td>
&lt;td>热修复分支&lt;/td>
&lt;td>处理线上最新版本出现的bug&lt;/td>
&lt;td>Develper可直接push&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fix/xxx&lt;/td>
&lt;td>旧版本修复分支&lt;/td>
&lt;td>处理线上旧版本的bug&lt;/td>
&lt;td>Develper可直接push&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="提交习惯">提交习惯&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>高频率、细粒度地提交&lt;/strong>&lt;/p>
&lt;p>必须把大功能的实现尽可能分解成相对独立的小模块，每个小模块需要完成测试后提交到代码库，再开始下一个模块的开发。
这样做能保证每次提交的内容高度相关，方便定位错误、解决合并冲突。
相比之下，如果每次提交的东西很多、改动很大、时间间隔很长，那么在代码合并过程中产生的冲突就很难解决。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>约定: 如果代码有改动，一天至少提交一次。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>提交之前需进行自测与单元测试&lt;/strong>&lt;/p>
&lt;p>提交代码前需要针对改动的代码进行自测和单元测试，确保在测试环境能平稳正常运行，否则代码提交后将无法通过持续集成的测试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分支合并&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>主分支合并&lt;/strong>&lt;/p>
&lt;p>主分支合并必须经过测试组测试，验收通过后才能合并。一般而言、每次迭代上线前一起合并。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>开发分支合并&lt;/strong>&lt;/p>
&lt;p>开发分支合并功能分支，尽量做到 &lt;strong>频繁合并&lt;/strong>，也就是说尽量将功能需求分解成 &lt;code>N&lt;/code> 个功能模块，
每一个功能模块完成就提交代码合并到开发分支，这样可以减少分支合并而造成冲突。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="代码提交的实例">代码提交的实例&lt;/h2>
&lt;p>当前存在版本(tag) &lt;code>1.0.0&lt;/code>，并规划推出新版本 &lt;code>1.1.0&lt;/code>，那么应该基于 &lt;code>1.0.0&lt;/code> 新建版本开发分支：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git checkout -b 1.1.0_develop
&lt;/code>&lt;/pre>&lt;/div>&lt;p>该开发版本有很多功能并且有多人参与。研发 a 参与视频模块开发，需要从 &lt;code>1.1.0_develop&lt;/code> 创建一个功能分支，
参考的分支命名规范是 &lt;code>{version}_{function}__{author}_{datetime}&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git checkout -b 1.1.0_video_a_20200806
&lt;/code>&lt;/pre>&lt;/div>&lt;p>研发 b 参与朋友圈模块开发，需要从 &lt;code>1.1.0_develop&lt;/code> 创建一个功能分支：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git checkout -b 1.1.0_friends_group_b_20200805
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>切记千万不要在开发分支直接提交代码 开发分支是合并分支&lt;/p>
&lt;/blockquote>
&lt;p>开发完毕合并功能分支，处于不断合并的过程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git merge 1.1.0_video_a_20200806
git merge 1.1.0_friends_group_b_20200805
&lt;/code>&lt;/pre>&lt;/div>&lt;p>自测完成后，没有问题那就将功能分支删除&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git branch -d 1.1.0_video_a_20200806
git branch -d 1.1.0_friends_group_b_20200805
&lt;/code>&lt;/pre>&lt;/div>&lt;p>提测发现有缺陷，需要基于版本迭代分支创建缺陷修复分支&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git checkout -b 1.1.0_fixed_video_upload_bug_alicfeng_20200808
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修复完成再合并到迭代分支&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git merge 1.1.0_fixed_video_upload_bug_alicfeng_20200808
&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试通过后 通过约定的方式 &lt;code>tag&lt;/code> 即为发布版本 发布 &lt;code>1.1.0&lt;/code> 版本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git tag -a 1.1.0 -m &lt;span style="color:#4e9a06">&amp;#34;release:version:1.1.0&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="线上发现缺陷后的仓库操作与协作约定">线上发现缺陷后的仓库操作与协作约定&lt;/h2>
&lt;ol>
&lt;li>基于版本标签新建热修复分支&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git checkout 1.1.0
git checkout -b hotfix_video_alicfeng_20200809
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>开发分支合并热修复分支&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git checkout develop
git merge hotfix_video_alicfeng_20200809
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>主分支合并开发分支&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git checkout master
git merge develop
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>基于主分支新建新的版本标签,务必在&lt;code>git&lt;/code>上编写更新内容&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git checkout hotfix_video_alicfeng_20200809
git tag -a 1.1.1 -m &lt;span style="color:#4e9a06">&amp;#34;fixed:video:upload&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试通过后推送到代码仓库&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 代码审阅</title><link>/docs/codestandards/codereview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/codestandards/codereview/</guid><description>
&lt;p>代码审阅（Code Review） 是项目中的必需项。代码审阅有助于提升代码的质量，尽早发现潜在的缺陷，降低修复的成本，
同时可以促进开发团队内部知识的共享，帮助开发者更好理解系统的业务与实现对于代码审阅的原则而言，
不定期地从小版本迭代(version) 或 新功能(feature)进行团队或者相关人员进行评审，评审的从架构、业务实现、技术等维度着手分析。&lt;/p>
&lt;h2 id="代码审阅流程">代码审阅流程&lt;/h2>
&lt;p>大致的审阅流程大致如下流程图所示，即&lt;/p>
&lt;ol>
&lt;li>
&lt;p>开发者完成开发后，将功能分支提交并提醒审阅者进行代码审阅；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>评审者审阅代码，假设没有存在问题则让开发者将功能分支合并至开发分支，否则组织评审会，指出相应的不合理之处并讨论出可行方案进行更改；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开发者根据修改方案进行代码修复，完成后再次提交。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">graph TB
subgraph 团队协作仓库
wait[稳住稳住]--&amp;gt;merge_code[合并功能分支]
end
subgraph 审阅者
review_code[评审提交代码]
is_modify{看看是否要修改}
review_code--&amp;gt;is_modify
is_modify-- 否 --&amp;gt;merge_code
is_modify-- 是 --&amp;gt;modify_code
end
subgraph 开发者
push_code[提交分支代码]
modify_code[修改代码]
modify_code-- 重新提交 --&amp;gt;push_code
push_code--&amp;gt;review_code
end
&lt;/code>&lt;/pre>&lt;h2 id="代码审阅范围">代码审阅范围&lt;/h2>
&lt;p>代码审阅应确保业务定义的功能正常运行以及业务后续的可迭代性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>业务处理&lt;/p>
&lt;p>即功能实现是否能正常运行、满足预期的效果，同时确保业务的合理性与可迭代性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>业务规范&lt;/p>
&lt;p>使用正确的姿势正确处理业务，尽量禁止特殊处理或者歧义方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范习惯&lt;/p>
&lt;p>必须编写并更新项目文档、接口文档。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>代码审阅必须遵循项目规范，主要是从项目规范审阅，详细查看其它规范章节：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>命名规范&lt;/p>
&lt;/li>
&lt;li>
&lt;p>日志输出&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码注释&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码优化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库规范&lt;/p>
&lt;/li>
&lt;li>
&lt;p>事务处理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码复用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>效率与性能 (稳定性、健壮性)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>事务处理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>项目架构目录定义规范&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可读性、可维护性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码安全性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单元测试&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="代码评审会">代码评审会&lt;/h2>
&lt;p>代码评审会类似于技术分享会，从中我们可以获取高级的技术用法以提高自身代码要求。合理安排代码审阅时间，一般安排1~2个小时。
根据项目规范与产品规划&lt;strong>指出问题&lt;/strong>、&lt;strong>讨论问题&lt;/strong>、&lt;strong>解决问题&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>devSpec 已经给出了 Go的编码规范与指南，可以根据指南来指导代码评审会。&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: 发行和版本控制</title><link>/docs/codestandards/version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/codestandards/version/</guid><description>
&lt;h2 id="版本控制">版本控制&lt;/h2>
&lt;h3 id="语义化版本控制规范">语义化版本控制规范&lt;/h3>
&lt;p>版本号格式为 x.y.z，其中 x 为大版本号，y 为小版本号，z 为补丁版本号。 版本号格式遵循 &lt;a href="https://semver.org/">Semantic Versioning&lt;/a>。&lt;/p>
&lt;p>以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>例如：1.9.1 -&amp;gt; 1.10.0 -&amp;gt; 1.11.0。&lt;/p>
&lt;/blockquote>
&lt;ol start="3">
&lt;li>
&lt;p>标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修订号 Z（x.y.Z | x &amp;gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>次版本号 Y（x.Y.z | x &amp;gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主版本号 X（X.y.z | X &amp;gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。&lt;/p>
&lt;/blockquote>
&lt;ol start="10">
&lt;li>版本编译元数据可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译元数据可（SHOULD）被忽略。因此当两个版本只有在版本编译元数据有差别时，属于相同的优先层级。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。&lt;/p>
&lt;/blockquote>
&lt;ol start="11">
&lt;li>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译元数据不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &amp;lt; 2.0.0 &amp;lt; 2.1.0 &amp;lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &amp;lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>范例：1.0.0-alpha &amp;lt; 1.0.0-alpha.1 &amp;lt; 1.0.0-alpha.beta &amp;lt; 1.0.0-beta &amp;lt; 1.0.0-beta.2 &amp;lt; 1.0.0-beta.11 &amp;lt; 1.0.0-rc.1 &amp;lt; 1.0.0。&lt;/p>
&lt;/blockquote>
&lt;h3 id="版本控制常见问题回答">版本控制常见问题回答&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>在 0.y.z 初始开发阶段，我该如何进行版本控制？&lt;/strong>
最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>如何判断发布 1.0.0 版本的时机？&lt;/strong>
当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>这不会阻碍快速开发和迭代吗？&lt;/strong>
主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？&lt;/strong>
这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>为整个公共 API 写文件太费事了！&lt;/strong>
为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？&lt;/strong>
一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>如果我更新了自己的依赖但没有改变公共 API 该怎么办？&lt;/strong>
由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）&lt;/strong>
自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>我该如何处理即将弃用的功能？&lt;/strong>
弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>语义化版本对于版本的字串长度是否有限制呢？&lt;/strong>
没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: 日志</title><link>/docs/codestandards/log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/codestandards/log/</guid><description/></item><item><title>Docs: 注释</title><link>/docs/codestandards/comment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/codestandards/comment/</guid><description/></item><item><title>Docs: 测试</title><link>/docs/codestandards/test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/codestandards/test/</guid><description/></item></channel></rss>